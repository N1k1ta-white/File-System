# Реализация на файлова система на Haskell

## Идея и решение

Курсовата работа представлява реализиране на опростена файлова система на функционален език за програмиране Haskell. Главната цел на проекта е да се симулират основни операции с файлове и директории, които включват:

- Създаване на файлове и директории
- Изтриване на файлове и директории
- Промяна на съдържанието на файлове
- Извеждане на съдържанието на файл или директория
- Навигация в структурата на файловата система
- Валидация на пътища

## Използвана структура от данни

Файловата система е представена като дървовидна структура, където всеки възел (node) може да бъде файл или директория. Всеки възел съдържа пълен път (path) и, ако е директория, списък от вложени възли. Тази организация позволява лесно представяне и управление на йерархията на файловата система.

```haskell
data FsNode
  = File String String
  | Directory String [FsNode]
  deriving (Eq)
```

## Характеристики на структурата

### Рекурсивно обновяване
Всяка промяна в даден възел (например добавяне, изтриване или промяна на съдържание) води до рекурсивно обновяване на всички родителски възли до корена на файловата система. Това гарантира консистентност на дървото, но добавя изчислителна сложност.

### Ефективност при навигация
Преходът между директории (например с команда `cd`) е изключително бърз благодарение на йерархичната структура и ефективните функции за намиране на възли.

### Разходи при операции
Операции като създаване, изтриване или модифициране на възли са по-ресурсоемки, тъй като включват промени в множество нива на структурата.

#### Главни функции и тяхното предназначение

##### **Основни функции**

1. **`getPath :: FsNode -> String`**

   - Връща пълния път на даден файл или директория.
   - **Пример**: За елемент `File "/home/user/file.txt" "content"`, функцията ще върне `"/home/user/file.txt"`.

2. **`fsName :: FsNode -> String`**

   - Извлича името на файла или директорията от техния пълен път.
   - **Пример**: За елемент `File "/home/user/file.txt" "content"`, функцията ще върне `"file.txt"`.

3. **`cd :: FsNode -> FsNode -> String -> FsNode`**

   - Променя текущата директория на базата на зададен път.
   - **Пример**: Ако текущата директория е `/home` и пътят е `"user/docs"`, функцията ще премести контекста в `/home/user/docs`.

4. **`ls :: FsNode -> [String]`**

   - Връща списък от имената на всички елементи в директорията.
   - **Пример**: За директория `Directory "/home" [File "/home/a.txt" "", File "/home/b.txt" ""]`, резултатът ще е `["a.txt", "b.txt"]`.

5. **`pwd :: FsNode -> String`**

   - Извежда текущия работен път.
   - **Пример**: За текуща директория `Directory "/home/user" []`, функцията ще върне `"/home/user"`.

##### **Функции за създаване и промяна**

1. **`mkEmptyDirectory :: FsNode -> FsNode -> String -> FsNode`**

   - Създава празна директория с дадено име в текущата директория.
   - **Пример**: Създаване на директория с име `"docs"` в `/home` ще добави `Directory "/home/docs" []` в структурата.

2. **`mkEmptyFile :: FsNode -> FsNode -> String -> FsNode`**

   - Създава празен файл с дадено име в текущата директория.
   - **Пример**: Създаване на файл с име `"file.txt"` в `/home` ще добави `File "/home/file.txt" ""` в структурата.

3. **`mkFile :: FsNode -> FsNode -> String -> String -> FsNode`**

   - Създава файл с дадено име и съдържание.
   - **Пример**: Създаване на файл `"file.txt"` със съдържание `"Hello, World!"` в `/home` ще добави `File "/home/file.txt" "Hello, World!"`.

4. **`changeFileContent :: FsNode -> FsNode -> String -> FsNode`**

   - Променя съдържанието на съществуващ файл.
   - **Пример**: За файл `File "/home/file.txt" "Old Content"`, функцията може да промени съдържанието на `"New Content"`.

##### **Функции за изтриване**

1. **`removeFile :: FsNode -> FsNode -> FsNode -> FsNode`**

   - Премахва даден файл от файловата система.
   - **Пример**: Премахване на `File "/home/file.txt" ""` от `Directory "/home" [...]` ще го изтрие от списъка на елементите.

2. **`removeFiles :: FsNode -> FsNode -> [FsNode] -> FsNode`**

   - Премахва списък от файлове.
   - **Пример**: Може да премахне всички файлове от директория `/home`, които съответстват на даден списък.

##### **Важни помощни функции**

1. **`updateDirectory :: FsNode -> FsNode -> FsNode -> FsNode`**

   - Рекурсивно актуализира съдържанието на директорията и всички нейни родителски директории, като добавя, трие или заменя елемент.
   - **Пример**: Ако `Directory "/home" [...]` съдържа `File "/home/a.txt" ""`, функцията ще исползва при добавяне, триене или замяна на този файл за да актуализира родителските директории до корена.

2. **`getFile :: FsNode -> FsNode -> String -> Maybe FsNode`**

   - Намира файл или директория по даден път.
   - **Пример**: За `getFile root current "/home/a.txt"`, резултатът ще бъде `Just (File "/home/a.txt" "")` или `Nothing`, ако файлът не съществува.

3. **`findChild :: String -> FsNode -> Maybe FsNode`**

   - Търси дете (файл или директория) в дадена директория по име.
   - **Пример**: За `Directory "/home" [File "/home/a.txt" ""]`, `findChild "a.txt"` ще върне `Just (File "/home/a.txt" "")`.

4. **`isConsist :: [FsNode] -> FsNode -> Bool`**

   - Проверява дали даден файл или директория вече съществуват в списъка от елементи.
   - **Пример**: Ако `Directory "/home" [...]` съдържа `File "/home/a.txt" ""`, резултатът ще бъде `True`.

5. **`validatePath :: FsNode -> FsNode -> String -> Bool`**

   - Валидира път, за да провери дали е валиден в контекста на текущата файловата система.
   - **Пример**: За път `"/home/user"`, функцията ще провери дали всички части на пътя съществуват и са достъпни.

6. **`splitPath :: String -> [String]`**

   - Разделя пътя на компоненти, като премахва символите за разделител `/`.
   - **Пример**: За път `"/home/user/docs"` функцията ще върне `["home", "user", "docs"]`.

7. **`removeLastElementInPath :: String -> String`**

   - Премахва последния компонент от даден път.
   - **Пример**: За път `"/home/user/docs"`, функцията ще върне `"/home/user/"`.

8. **`getParent :: FsNode -> FsNode -> FsNode`**

   - Връща родителската директория на даден елемент.
   - **Пример**: За `File "/home/user/file.txt" ""`, функцията ще върне `Directory "/home/user" [...]`.

9. **`isDirectory :: Maybe FsNode -> Bool`**

   - Проверява дали даден елемент е директория.
   - **Пример**: Ако елементът е `Just (Directory "/home" [...])`, резултатът ще е `True`, а за `Just (File "/home/a.txt" "")` ще е `False`.

10. **`catFiles :: [FsNode] -> String`**

    - Обединява съдържанието на няколко файла в един текстов низ.
    - **Пример**: За файлове `[File "/file1.txt" "Hello", File "/file2.txt" "World"]` резултатът ще бъде `"Hello
      World"`.

##### Инструкция за стартиране на проекта с помощта на `cabal`

1. **Отворете терминал**:
   Уверете се, че имате инсталиран Haskell с `cabal` и всички необходими зависимости.

2. **Навигирайте до папката на проекта**:
   ```bash
   cd /път/до/папката/на/проекта
   ```

3. **Компилация на проекта**:
   За да компилирате проекта, изпълнете:
   ```bash
   cabal build
   ```

   Ако проектът се компилира успешно, ще видите съобщение за успешна компилация.

4. **Стартиране на проекта**:
   За да стартирате изпълнимия файл след компилацията, използвайте:
   ```bash
   cabal run
   ```

   Тази команда ще компилира отново проекта (ако има промени) и ще го стартира.

5. **Допълнителни забележки**:
   - Ако проектът има специфични входни данни или изисквания, проверете секцията за настройка в предоставените файлове или документация.
   - В случай на проблеми с библиотеките или зависимостите, изпълнете:
     ```bash
     cabal update
     cabal install
     ``` 